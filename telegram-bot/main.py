import sys

import telebot
import requests
import time
import threading
import subprocess

from telebot import types
from requests import get
from datetime import datetime

from google_calendar import radio_scheduler

# Load variables data from the config file
from config import (
    TELEGRAM_TOKEN,
    TELEGRAM_VOICE_CHAT_LINK,
    TELEGRAM_VOICE_CHAT_KEY,
    STREAM_URL,
    STREAM_STATUS,
    ADMINS,
    SUPPORT
)

bot = telebot.TeleBot(TELEGRAM_TOKEN)  # variable to provide Telegram bot token to the Telebot
stream_process = None  # variable to store the stream process
stream_command = ['ffmpeg', '-stream_loop', '-1', '-re', '-i', STREAM_URL,
                  '-c:v', 'libx264', '-c:a', 'aac', '-b:a', '192k',
                  '-f', 'flv', '-flvflags', 'no_duration_filesize',
                  TELEGRAM_VOICE_CHAT_LINK + TELEGRAM_VOICE_CHAT_KEY]


# Function to create the formatted timestamp
def timestamp():
    current_time = datetime.now()  # variable to get current date
    green = '\033[92m'  # ANSI escape sequence for green color text
    reset = '\033[0m'  # ANSI escape sequence to reset text color
    timestamp_formatted = f'{green}{current_time.strftime("%Y-%m-%d %H:%M:%S")}{reset}\n-------------------\n'
    return f'\n\n{timestamp_formatted}'


# Function to update the log file
def logging(error):
    sys.stderr.write(error)
    with open('/var/log/telegram-bot.log', 'a') as file:
        file.write(f'\n{timestamp()}'
                   f'{error}')


# Function to check stream URL is available
def stream_url_status():
    attempt = 1
    while attempt < 6:
        response = requests.get(STREAM_URL, stream=True)
        if response:
            print(f'attempt {attempt}:\n'
                  f'----------\n'
                  f'=> URL: {STREAM_URL}\n'
                  f'=> Response: {response.status_code}\n')
            return True
        else:
            print(f'attempt {attempt}:\n'
                  f'----------\n'
                  f'=> URL: {STREAM_URL}\n'
                  f'=> Response: {response.status_code}\n')
            time.sleep(5)
            attempt += 1
    return False


# Function to play the stream
def stream_play():
    global stream_process
    if stream_process is None:
        print(f'{timestamp()}'
              f'=> Starting the stream process...\n'
              f'=> Command: {" ".join(stream_command)}\n')
        stream_process = subprocess.Popen(stream_command,
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE,
                                          universal_newlines=True)
        output, error = stream_process.communicate()
        stream_error(error)


# Function to stop the stream
def stream_stop():
    global stream_process
    print(f'\n{timestamp()}'
          f'=> Stopping the stream process...\n')
    if stream_process is not None:
        stream_process.terminate()
        stream_process.wait()
        stream_process = None
        print('\n=> Stream stopped!\n')


# Function to restart the stream
def stream_restart():
    global stream_process
    print(f'{timestamp()}'
          f'=> Restarting the stream process...\n')
    stream_process.terminate()
    stream_process.wait()
    stream_process = None
    stream_thread = threading.Thread(target=stream_play)
    stream_thread.start()


# Function to parse the output for the known errors
def stream_error(error):
    if "Function not implemented" in error:
        print(f'\n{timestamp()}'
              f'=> ERROR: connection to the Icecast2 server interrupted.\n')
        logging(error)
        time.sleep(15)
        stream_restart()
    elif "I/O error" and "Failed to resolve hostname" in error:
        print(f'\n{timestamp()}'
              f'=> ERROR: connection to the Icecast2 server failed.\n')
        logging(error)
        time.sleep(15)
        stream_restart()
    elif "Conversion failed!" in error:
        print(f'\n{timestamp()}'
              f'=> ERROR: ffmpeg conversion failed.\n')
        logging(error)
        time.sleep(15)
        stream_restart()
    elif "I/O error" and "Error opening output rtmps" in error:
        print(f'\n{timestamp()}'
              f'=> ERROR: voice chat in the Telegram group is busy.\n')
        logging(error)
        time.sleep(30)
        stream_restart()
    elif "Error" or "error" or "Failed" or "failed" in error:
        print(f'\n{timestamp()}'
              f'=> ERROR: unknown error - check the logs.\n')
        logging(error)
        time.sleep(30)
        stream_restart()


# Function to parse the current song
def get_song():
    resp = get(STREAM_STATUS).json()
    return resp.get("icestats").get("source").get("title")


# Function to get the chat ID for a given username
def get_chat_id(username):
    try:
        user_info = bot.get_chat(username)
        return user_info.id
    except telebot.apihelper.ApiTelegramException:
        return None


# Function to send the report to support
def report_process(message):
    report_text = message.text
    # Send the report to support users (SUPPORT only)
    for username in SUPPORT:
        support_chat_id = get_chat_id(username)
        if support_chat_id:
            bot.send_message(support_chat_id,
                             f'–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n'
                             f'=========================\n'
                             f'Username: {message.from_user.username}\n'
                             f'ID: {message.from_user.id}\n'
                             f'=========================\n'
                             f'{report_text}')
        else:
            bot.reply_to(message, f'üö´ –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {username}!\n')
    # Send a confirmation message to the user
    bot.reply_to(message, 'üëçüèª –°–ø–∞—Å–∏–±–æ!\n–í–∞—à –∑–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.')


# Handler for the /start command
@bot.message_handler(commands=['start'])
def handle_start(message):
    if message.chat.type == 'private':  # check the chat is private
        # Send a photo along with the start command response
        photo_url = 'https://radio.daomars.net/wp-content/uploads/2023/05/flood-morning-300x300.png'
        bot.send_photo(message.chat.id, photo_url, caption='–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤—Ç—å –≤ –±–æ—Ç–∞ MarsDAO Radio!')
        handle_menu(message)  # Call the handle_menu function to show the menu message and buttons
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /play command
@bot.message_handler(commands=['play'])
# Handler for the Play button (ADMINS only)
@bot.message_handler(func=lambda message: message.text == '‚ñ∂Ô∏è Play')
def handle_play(message):
    if message.chat.type == 'private':  # check the chat is private
        if message.from_user.id in ADMINS:
            if stream_process is not None:
                bot.send_message(message.chat.id, 'üö´ –û—à–∏–±–∫–∞!\n–í–µ—â–∞–Ω–∏–µ —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram —É–∂–µ –∑–∞–ø—É—â–µ–Ω–æ!')
            else:
                bot.reply_to(message, '‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫ –≤–µ—â–∞–Ω–∏—è —Ä–∏–¥–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram...')
                stream = threading.Thread(target=stream_play)
                stream.start()
        else:
            bot.reply_to(message, 'üö´ –û—à–∏–±–∫–∞!\n–£ –≤–∞—Å –Ω–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.')
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /stop command
@bot.message_handler(commands=['stop'])
# Handler for the Stop button (ADMINS only)
@bot.message_handler(func=lambda message: message.text == '‚èπÔ∏è Stop')
def handle_stop(message):
    if message.chat.type == 'private':  # check the chat is private
        if message.from_user.id in ADMINS:
            bot.reply_to(message, '‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–µ—â–∞–Ω–∏—è —Ä–∏–¥–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram...')
            stream_stop()
        else:
            bot.reply_to(message, 'üö´ –û—à–∏–±–∫–∞!\n–£ –≤–∞—Å –Ω–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.')
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /restart command
@bot.message_handler(commands=['restart'])
# Handler for the Restart button (ADMINS only)
@bot.message_handler(func=lambda message: message.text == 'üîÑ Restart')
def handle_restart(message):
    if message.chat.type == 'private':  # check the chat is private
        if message.from_user.id in ADMINS:
            bot.reply_to(message, 'üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –≤–µ—â–∞–Ω–∏—è —Ä–∏–¥–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram...')
            stream_restart()
        else:
            bot.reply_to(message, 'üö´ –û—à–∏–±–∫–∞!\n–£ –≤–∞—Å –Ω–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.')
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /status command
@bot.message_handler(commands=['status'])
# Handler for the Restart button (ADMINS only)
@bot.message_handler(func=lambda message: message.text == '‚ÑπÔ∏è Status')
def handle_status(message):
    if message.chat.type == 'private':  # check the chat is private
        global stream_process
        if stream_process is not None:
            bot.send_message(message.chat.id, '‚ÑπÔ∏è –í–µ—â–∞–Ω–∏–µ —Ä–∏–¥–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram —Ä–∞–±–æ—Ç–∞–µ—Ç!')
        else:
            bot.send_message(message.chat.id, 'üö´ –í–µ—â–∞–Ω–∏–µ —Ä–∏–¥–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram –ù–ï —Ä–∞–±–æ—Ç–∞–µ—Ç!')
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /song command
@bot.message_handler(commands=['song'])
# Handler for the Song button
@bot.message_handler(func=lambda message: message.text == 'üé∂ Song')
def handle_song(message):
    if message.chat.type == 'private':  # check the chat is private
        bot.reply_to(message, f'üé∂ –°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç:\n{get_song()}')
    else:
        song_text = f'üé∂ –°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç:\n{get_song()}'
        bot.send_message(message.chat.id, song_text)
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /report command
@bot.message_handler(commands=['report'])
# Handler for the Report button
@bot.message_handler(func=lambda message: message.text == 'üí¨ Report')
def handle_report(message):
    if message.chat.type == 'private':  # check the chat is private
        # Create the cancel button
        markup = types.InlineKeyboardMarkup()
        cancel_button = types.InlineKeyboardButton('üö´ Cancel', callback_data='cancel_report')
        markup.add(cancel_button)

        # Send a prompt message to the user with the cancel button
        prompt_message = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ—ë —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Å–ª—É–∂–±—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã –¥–ª—è –ø—Ä–µ–∫—Ä–∞—â–µ–Ω–∏—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è:'
        bot.send_message(message.chat.id, prompt_message, reply_markup=markup)

        # Register the next message handler to listen for the report
        bot.register_next_step_handler(message, report_process)
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for processing callback from the cancel button
@bot.callback_query_handler(func=lambda call: call.data == 'cancel_report')
def handle_cancel_report(call):
    # Send a message in the chat that the report has been cancelled
    bot.send_message(call.message.chat.id, 'üö´ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.')

    # Delete the original message with the report
    bot.delete_message(call.message.chat.id, call.message.message_id)

    # Clear the next step handler for the current chat
    bot.clear_step_handler_by_chat_id(call.message.chat.id)


# Handler for the /help command
@bot.message_handler(commands=['help'])
# Handler for the Help button
@bot.message_handler(func=lambda message: message.text == '‚ùì Help')
def handle_help(message):
    if message.chat.type == 'private':  # check the chat is private
        help_text = '''
–≠—Ç–æ —Ä–∞–∑–¥–µ–ª –ø–æ–º–æ—â–∏ –±–æ—Ç–∞ MarsDAO Radio.

–ì—Ä—É–ø–ø–∞ —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏: https://t.me/MarsDAO_radio
–°–∞–π—Ç —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏: https://radio.daomars.net

–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞
/play - –ó–∞–ø—É—Å—Ç–∏—Ç—å –≤–µ—â–∞–Ω–∏–µ —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)
/stop - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ—â–∞–Ω–∏–µ —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)
/restart - –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –≤–µ—â–∞–Ω–∏–µ —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)
/status - –°—Ç–∞—Ç—É—Å –≤–µ—â–∞–Ω–∏—è —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –≤ Telegram
/scheduler - –ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Å–µ—Ç–∫–∏ –≤–µ—â–∞–Ω–∏—è —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é
/song - –ü–æ–ª—É—á–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –≤ —ç—Ñ–∏—Ä–µ
/report - –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∫–∏

–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –Ω–∏–∂–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º.
    '''
        bot.reply_to(message, help_text)
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the /scheduler command
@bot.message_handler(commands=['scheduler'])
# Handler for the Help button
@bot.message_handler(func=lambda message: message.text == 'üìÜ Scheduler')
def handle_help(message):
    if message.chat.type == 'private':  # check the chat is private
        scheduler_text = radio_scheduler()
        if scheduler_text:
            bot.reply_to(message, scheduler_text)
        else:
            bot.reply_to(message, 'üö´ –û—à–∏–±–∫–∞!\n–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏ —Å–µ—Ç–∫–∏ –≤–µ—â–∞–Ω–∏—è —Ä–∞–¥–∏–æ—Å—Ç–∞–Ω—Ü–∏–∏ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞.')
    else:
        # Skip execution for the non-private chats and remove the command message
        bot.delete_message(message.chat.id, message.message_id)


# Handler for the main menu
@bot.message_handler(func=lambda message: True)
def handle_menu(message):
    if message.chat.type == 'private':  # check the chat is private
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        if message.from_user.id in ADMINS:
            button_play = types.InlineKeyboardButton('‚ñ∂Ô∏è Play')
            button_stop = types.InlineKeyboardButton('‚èπÔ∏è Stop')
            button_restart = types.InlineKeyboardButton('üîÑ Restart')
            markup.row(button_play, button_stop)
            markup.row(button_restart)
        button_song = types.InlineKeyboardButton('üé∂ Song')
        button_scheduler = types.InlineKeyboardButton('üìÜ Scheduler')
        markup.row(button_song, button_scheduler)
        button_status = types.InlineKeyboardButton('‚ÑπÔ∏è Status')
        button_report = types.InlineKeyboardButton('üí¨ Report')
        button_help = types.InlineKeyboardButton('‚ùì Help')
        markup.row(button_status, button_report, button_help)
        bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –∏–∑ –º–µ–Ω—é, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º MarsDAO Radio üëáüèª',
                         reply_markup=markup)


# Start the bot
def main():
    print(f'\n\n\n===============================\n'
          f'MarsDAO Radio bot version 1.3.0'
          f'\n===============================\n\n'
          f'Source: https://github.com/profinch/telegram-bot-icecast-radio'
          f'{timestamp()}'
          f'=> Checking the stream URL...\n')
    if stream_url_status():
        print('=> The stream URL is available.')
    else:
        print(f'{timestamp()}'
              f'=> ERROR: Stream URL is not available!\n'
              f'=> Bye!')
        quit()
    try:
        print('\n=> Starting the stream in...')
        for i in range(3, 0, -1):
            print(f'=> {i} seconds')
            time.sleep(1)
        stream = threading.Thread(target=stream_play)
        stream.start()
        time.sleep(1)
        print('=> Starting the bot polling...\n')
        bot.polling(none_stop=True, timeout=60)
    except Exception as error_polling:
        print(f'\n{timestamp()}'
              f'\n=> An error occurred while polling:', str(error_polling))
        print(f'\n=> Bye!\n')
        quit()


if __name__ == '__main__':
    main()
